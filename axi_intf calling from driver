Got it—since those registers are memory-mapped and you’re accessing them over AXI, here’s a clean AXI4-Lite master BFM you can call from your driver via register_write() / register_read().
// axi_lite_if.sv
interface axi_lite_if #(parameter ADDR_W=32, DATA_W=32) (input logic aclk, input logic aresetn);

  // Write address channel
  logic                 awvalid;
  logic                 awready;
  logic [ADDR_W-1:0]    awaddr;

  // Write data channel
  logic                 wvalid;
  logic                 wready;
  logic [DATA_W-1:0]    wdata;
  logic [(DATA_W/8)-1:0] wstrb;

  // Write response channel
  logic                 bvalid;
  logic                 bready;
  logic [1:0]           bresp;

  // Read address channel
  logic                 arvalid;
  logic                 arready;
  logic [ADDR_W-1:0]    araddr;

  // Read data channel
  logic                 rvalid;
  logic                 rready;
  logic [DATA_W-1:0]    rdata;
  logic [1:0]           rresp;

  // ------------------------------------------------------------
  // Simple AXI4-Lite MASTER tasks (blocking)
  // ------------------------------------------------------------
  task automatic axi_write(input  logic [ADDR_W-1:0] addr,
                           input  logic [DATA_W-1:0] data,
                           input  logic [(DATA_W/8)-1:0] strb = '1);
    // Drive address/data
    @(posedge aclk);
    awaddr  <= addr;
    awvalid <= 1'b1;
    wdata   <= data;
    wstrb   <= strb;
    wvalid  <= 1'b1;
    bready  <= 1'b1;

    // Wait for AW and W handshakes (independent)
    while (!(awvalid && awready)) @(posedge aclk);
    awvalid <= 1'b0;

    while (!(wvalid && wready)) @(posedge aclk);
    wvalid <= 1'b0;

    // Wait for BRESP
    while (!bvalid) @(posedge aclk);
    // Optional: check bresp == OKAY(2’b00)
    if (bresp != 2'b00)
      $error("AXI-Lite write BRESP error: %0b at addr 0x%08h", bresp, addr);
    // Complete B handshake
    @(posedge aclk);
    bready <= 1'b0;
  endtask

  task automatic axi_read (input  logic [ADDR_W-1:0] addr,
                           output logic [DATA_W-1:0] data_o);
    @(posedge aclk);
    araddr  <= addr;
    arvalid <= 1'b1;
    rready  <= 1'b1;

    // Wait for AR handshake
    while (!(arvalid && arready)) @(posedge aclk);
    arvalid <= 1'b0;

    // Wait for RVALID
    while (!rvalid) @(posedge aclk);
    data_o = rdata;
    // Optional: check rresp == OKAY(2’b00)
    if (rresp != 2'b00)
      $error("AXI-Lite read RRESP error: %0b at addr 0x%08h", rresp, addr);

    @(posedge aclk);
    rready <= 1'b0;
  endtask

  // ------------------------------------------------------------
  // Reset defaults
  // ------------------------------------------------------------
  // Ensure outputs are known on reset
  initial begin
    awvalid = 0; wvalid = 0; bready = 0;
    arvalid = 0; rready = 0;
    awaddr  = '0; wdata  = '0; wstrb = '0;
    araddr  = '0;
  end

endinterface
...........................................................................Driver...................................................................................................
// real_driver.sv (excerpt)
class real_driver extends uvm_driver #(real_item);
  `uvm_component_utils(real_driver)

  virtual axi_lite_if vif; // bind via config_db in your env

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  // Convenience wrappers
  task automatic register_write(logic [31:0] addr, logic [31:0] data);
    vif.axi_write(addr, data, '1); // full byte enables
    `uvm_info("DRV", $sformatf("WRITE  [0x%08h] = 0x%08h", addr, data), UVM_LOW)
  endtask

  task automatic register_read (logic [31:0] addr, output logic [31:0] data);
    vif.axi_read(addr, data);
    `uvm_info("DRV", $sformatf("READ   [0x%08h] -> 0x%08h", addr, data), UVM_LOW)
  endtask

  virtual task run_phase(uvm_phase phase);
    real_item tr;
    forever begin
      seq_item_port.get_next_item(tr);

      if (tr.start) begin
        for (int c = 0; c < tr.chunk_start_addr.size(); c++) begin
          logic [31:0] start = tr.chunk_start_addr[c];
          logic [31:0] end   = tr.chunk_end_addr[c];

          // Program DUT registers
          register_write(32'h0002, start);  // START_ADDR
          register_write(32'h0003, end);    // END_ADDR
          register_write(32'h0000, 32'h1);  // CONTROL.start=1

          // Poll STATUS.done
          logic [31:0] status;
          do begin
            register_read(32'h0001, status); // STATUS
          end while ((status & 32'h1) == 0);

          // Read CHECKSUM
          logic [31:0] calc_cksum;
          register_read(32'h0004, calc_cksum);
          `uvm_info("DRIVER",
            $sformatf("Chunk %0d: DUT Checksum = 0x%08h", c, calc_cksum),
            UVM_MEDIUM)
        end
      end

      seq_item_port.item_done();
    end
  endtask
endclass
.............................................................................................tb_top.........................................................................................
module tb_top;
  logic aclk, aresetn;
  axi_lite_if axi_if(aclk, aresetn);

  // DUT connections:
  // .S_AXI_AWVALID(axi_if.awvalid), .S_AXI_AWREADY(axi_if.awready), .S_AXI_AWADDR(axi_if.awaddr), ...
  // .S_AXI_WVALID (axi_if.wvalid ), .S_AXI_WREADY (axi_if.wready ), .S_AXI_WDATA (axi_if.wdata ), .S_AXI_WSTRB(axi_if.wstrb),
  // .S_AXI_BVALID (axi_if.bvalid ), .S_AXI_BREADY (axi_if.bready ), .S_AXI_BRESP (axi_if.bresp ),
  // .S_AXI_ARVALID(axi_if.arvalid), .S_AXI_ARREADY(axi_if.arready), .S_AXI_ARADDR(axi_if.araddr),
  // .S_AXI_RVALID (axi_if.rvalid ), .S_AXI_RREADY (axi_if.rready ), .S_AXI_RDATA (axi_if.rdata ), .S_AXI_RRESP(axi_if.rresp)

  // Clock/reset generation...
endmodule
